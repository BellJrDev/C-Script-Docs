"use strict";(self.webpackChunkcppdocs=self.webpackChunkcppdocs||[]).push([[828],{4600:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guides/SpecialTypes/Nullable","title":"Nullable<T>","description":"Nullable is a C++ified implementation of TypeScript\'s T? type and T | undefined return type.","source":"@site/docs/guides/SpecialTypes/Nullable.md","sourceDirName":"guides/SpecialTypes","slug":"/guides/SpecialTypes/Nullable","permalink":"/C-Script-Docs/docs/guides/SpecialTypes/Nullable","draft":false,"unlisted":false,"editUrl":"https://github.com/BellJrDev/C-Script-Docs/edit/main/docs/guides/SpecialTypes/Nullable.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"DList","permalink":"/C-Script-Docs/docs/guides/Lists/DList"},"next":{"title":"Array","permalink":"/C-Script-Docs/docs/guides/Array"}}');var l=n(4848),t=n(8453);const o={},r="Nullable<T>",a={},c=[{value:"<em>Purpose &amp; Problems Solved</em>",id:"purpose--problems-solved",level:4},{value:"API Reference",id:"api-reference",level:2},{value:"Key Features",id:"key-features",level:2},{value:"<em>Features + Performance + Ergonomics</em>",id:"features--performance--ergonomics",level:4},{value:"Usage Scenarios",id:"usage-scenarios",level:2},{value:"Quirks &amp; Limitations",id:"quirks--limitations",level:2},{value:"Initialize Destination Variable Beforehand",id:"initialize-destination-variable-beforehand",level:3},{value:"Design Decisions",id:"design-decisions",level:2},{value:"Examples",id:"examples",level:2}];function d(e){const i={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"nullablet",children:(0,l.jsx)(i.code,{children:"Nullable<T>"})})}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"Nullable<T>"})," is a C++ified implementation of TypeScript's ",(0,l.jsx)(i.code,{children:"T?"})," type and ",(0,l.jsx)(i.code,{children:"T | undefined"})," return type."]}),"\n",(0,l.jsx)(i.h4,{id:"purpose--problems-solved",children:(0,l.jsx)(i.em,{children:"Purpose & Problems Solved"})}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Using a ",(0,l.jsx)(i.code,{children:"Nullable<T>"}),' object indicates that the object may or may not be "null" at any point in time.']}),"\n",(0,l.jsxs)(i.li,{children:["Allows for a return type similar to TypeScript's ",(0,l.jsx)(i.code,{children:"T | Undefined"})]}),"\n",(0,l.jsxs)(i.li,{children:["Designed to place less responsibility on clients to do safety checks on the object (compared to something like ",(0,l.jsx)(i.code,{children:"std::optional"}),")"]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["To resolve a ",(0,l.jsx)(i.code,{children:"Nullable<T>"})," object into it' non-null T equivalent, a Resolve() method has been provided, among others."]}),"\n",(0,l.jsx)(i.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,l.jsxs)(i.p,{children:["[ Doxy Link Space ]",(0,l.jsx)(i.br,{}),"\n","This space will be linked to the doxygen page for this API as soon as it's created."]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsx)(i.h2,{id:"key-features",children:"Key Features"}),"\n",(0,l.jsx)(i.h4,{id:"features--performance--ergonomics",children:(0,l.jsx)(i.em,{children:"Features + Performance + Ergonomics"})}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Resolve()"})," and ",(0,l.jsx)(i.code,{children:"TryUse()"})," make using the underlying data a smooth process."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"constexpr"})," method signatures optimize move semantics for std containers."]}),"\n",(0,l.jsx)(i.li,{children:"The API is minimal for a clutter-free experience befitting this kind of wrapper."}),"\n"]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsx)(i.h2,{id:"usage-scenarios",children:"Usage Scenarios"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"(A) Return value for functions to return on fail"}),(0,l.jsx)(i.br,{}),"\n",'Sometimes there is no good "default" value in a given context. In these cases, it is recommended to return ',(0,l.jsx)(i.code,{children:"Nullable<T>"})," to prevent confusion."]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"This also makes functions more robust by enabling them to work with types without default constructor support."}),"\n"]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"(B) Data type to convey possible nullness"}),(0,l.jsx)(i.br,{}),"\n","Many cases involve data that necessarily lacks nullness guarantees at some point (e.g. external queries, creation based on conditions, etc.). Storing such data as ",(0,l.jsx)(i.code,{children:"Nullable<T>"})," is beneficial in 2 ways."]}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Anyone seeing the type will immediately know that it's potentially null."}),"\n",(0,l.jsxs)(i.li,{children:["It is a simple way of representing the information, not having the caveats of the nullptr method.","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"No worries about someone deleting the data using the pointer"}),"\n",(0,l.jsxs)(i.li,{children:["No need to directly handle using move semantics or smart pointer logic just to achieve possible nullness",(0,l.jsx)(i.br,{}),"\n","(Neither of these are bad, of course. There's just no need to buy a new car if all you really need is a new back wheel.)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsx)(i.h2,{id:"quirks--limitations",children:"Quirks & Limitations"}),"\n",(0,l.jsx)(i.h3,{id:"initialize-destination-variable-beforehand",children:"Initialize Destination Variable Beforehand"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"Resolve()"})," and ",(0,l.jsx)(i.code,{children:"TryUse()"})," help you safely unwrap a ",(0,l.jsx)(i.code,{children:"Nullable<T>"}),", but they don\u2019t magically initialize your variables."]}),"\n",(0,l.jsxs)(i.p,{children:["Given a ",(0,l.jsx)(i.code,{children:"Nullable<T>"})," in a null state, ",(0,l.jsx)(i.code,{children:"Resolve()"})," simply returns false without making any update to the destination variable."]}),"\n",(0,l.jsxs)(i.p,{children:["But if destination was never initialized before it was given to ",(0,l.jsx)(i.code,{children:"Resolve()"}),", then it is still uninitialized after execution. This is a classic recipe for undefined behavior, not specific to ",(0,l.jsx)(i.code,{children:"Nullable<T>"})," or ",(0,l.jsx)(i.code,{children:"C-Script"}),", but rather inherent to programming."]}),"\n",(0,l.jsxs)(i.p,{children:["Therefore, to prevent falling into that trap, ",(0,l.jsx)(i.strong,{children:"always initialize variables before they are used"})," -- even variables used as input params to callables like ",(0,l.jsx)(i.code,{children:"Resolve()"}),"."]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsx)(i.h2,{id:"design-decisions",children:"Design Decisions"}),"\n",(0,l.jsx)(i.p,{children:"I knew that I wanted 2 things to come from this class:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:'A convenient way to convey "possibly null" types in C++'}),"\n",(0,l.jsx)(i.li,{children:"A smooth way to resolve a possibly-null object into a hard type."}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["C++ doesn't have a ",(0,l.jsx)(i.code,{children:"?"})," overload for nullness like TypeScript's ",(0,l.jsx)(i.code,{children:"T?"}),". In fact, it's not even possible to write one, since the ternary operator is forbidden for custom overloading in C++. Additionally, C++ functions can't really return different hard (definite) types.\n(Returning Derived* as a Base* does not achieve this, since the compiler still isn't actually resolving the base --\x3e derived)."]}),"\n",(0,l.jsx)(i.p,{children:"For design problems like this one, I like to use the responsibility inversion method. In some cases, I find that you can invert the responsibility of two parties and achieve your desired result without introducing much boilerplate or verbosity."}),"\n",(0,l.jsxs)(i.p,{children:["In this case, I specifically noticed that I could invert the responsibility of providing a valid object to hold the resolved data. Instead of the normal apporach of having the function be responsibile for returning a valid T object and making the client store it, I flipped it. Now the client must give ",(0,l.jsx)(i.code,{children:"Resolve()"})," the valid T object, and the function only cares about receiving the storage variable."]}),"\n",(0,l.jsx)(i.p,{children:"This inversion of responsibility means:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Developers stay in control of variable initialization and lifetime"}),"\n",(0,l.jsx)(i.li,{children:"The API stays clean and minimal \u2014 no mystery magic, just clear contracts"}),"\n",(0,l.jsxs)(i.li,{children:["Positive safety and DX implications follow","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Removing the possibility of nullptr dereferences and hidden heap allocations makes working with ",(0,l.jsx)(i.code,{children:"Nullable<T>"})," straighforward and safety-conscious."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)("br",{}),"\n",(0,l.jsx)(i.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(i.p,{children:"[ Example Space ]"})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var s=n(6540);const l={},t=s.createContext(l);function o(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);